<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.11: http://docutils.sourceforge.net/" />
<title>Mu0 compiler and simulator</title>
<meta name="date" content="2014-11-13" />
<meta name="author" content="Nikolaos Kavvadias &lt;nikos&#64;nkavvadias.com&gt;" />
<style type="text/css">

/*
:Author: David Goodger (goodger@python.org)
:Id: $Id$
:Copyright: This stylesheet has been placed in the public domain.

Default cascading style sheet for the HTML output of Docutils.

See http://docutils.sf.net/docs/howto/html-stylesheets.html for how to
customize this style sheet.
*/

/* used to remove borders from tables and images */
.borderless, table.borderless td, table.borderless th {
  border: 0 }

table.borderless td, table.borderless th {
  /* Override padding for "table.docutils td" with "! important".
     The right padding separates the table cells. */
  padding: 0 0.5em 0 0 ! important }

.first {
  /* Override more specific margin styles with "! important". */
  margin-top: 0 ! important }

.last, .with-subtitle {
  margin-bottom: 0 ! important }

.hidden {
  display: none }

a.toc-backref {
  text-decoration: none ;
  color: black }

blockquote.epigraph {
  margin: 2em 5em ; }

dl.docutils dd {
  margin-bottom: 0.5em }

object[type="image/svg+xml"], object[type="application/x-shockwave-flash"] {
  overflow: hidden;
}

/* Uncomment (and remove this text!) to get bold-faced definition list terms
dl.docutils dt {
  font-weight: bold }
*/

div.abstract {
  margin: 2em 5em }

div.abstract p.topic-title {
  font-weight: bold ;
  text-align: center }

div.admonition, div.attention, div.caution, div.danger, div.error,
div.hint, div.important, div.note, div.tip, div.warning {
  margin: 2em ;
  border: medium outset ;
  padding: 1em }

div.admonition p.admonition-title, div.hint p.admonition-title,
div.important p.admonition-title, div.note p.admonition-title,
div.tip p.admonition-title {
  font-weight: bold ;
  font-family: sans-serif }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title, .code .error {
  color: red ;
  font-weight: bold ;
  font-family: sans-serif }

/* Uncomment (and remove this text!) to get reduced vertical space in
   compound paragraphs.
div.compound .compound-first, div.compound .compound-middle {
  margin-bottom: 0.5em }

div.compound .compound-last, div.compound .compound-middle {
  margin-top: 0.5em }
*/

div.dedication {
  margin: 2em 5em ;
  text-align: center ;
  font-style: italic }

div.dedication p.topic-title {
  font-weight: bold ;
  font-style: normal }

div.figure {
  margin-left: 2em ;
  margin-right: 2em }

div.footer, div.header {
  clear: both;
  font-size: smaller }

div.line-block {
  display: block ;
  margin-top: 1em ;
  margin-bottom: 1em }

div.line-block div.line-block {
  margin-top: 0 ;
  margin-bottom: 0 ;
  margin-left: 1.5em }

div.sidebar {
  margin: 0 0 0.5em 1em ;
  border: medium outset ;
  padding: 1em ;
  background-color: #ffffee ;
  width: 40% ;
  float: right ;
  clear: right }

div.sidebar p.rubric {
  font-family: sans-serif ;
  font-size: medium }

div.system-messages {
  margin: 5em }

div.system-messages h1 {
  color: red }

div.system-message {
  border: medium outset ;
  padding: 1em }

div.system-message p.system-message-title {
  color: red ;
  font-weight: bold }

div.topic {
  margin: 2em }

h1.section-subtitle, h2.section-subtitle, h3.section-subtitle,
h4.section-subtitle, h5.section-subtitle, h6.section-subtitle {
  margin-top: 0.4em }

h1.title {
  text-align: center }

h2.subtitle {
  text-align: center }

hr.docutils {
  width: 75% }

img.align-left, .figure.align-left, object.align-left {
  clear: left ;
  float: left ;
  margin-right: 1em }

img.align-right, .figure.align-right, object.align-right {
  clear: right ;
  float: right ;
  margin-left: 1em }

img.align-center, .figure.align-center, object.align-center {
  display: block;
  margin-left: auto;
  margin-right: auto;
}

.align-left {
  text-align: left }

.align-center {
  clear: both ;
  text-align: center }

.align-right {
  text-align: right }

/* reset inner alignment in figures */
div.align-right {
  text-align: inherit }

/* div.align-center * { */
/*   text-align: left } */

ol.simple, ul.simple {
  margin-bottom: 1em }

ol.arabic {
  list-style: decimal }

ol.loweralpha {
  list-style: lower-alpha }

ol.upperalpha {
  list-style: upper-alpha }

ol.lowerroman {
  list-style: lower-roman }

ol.upperroman {
  list-style: upper-roman }

p.attribution {
  text-align: right ;
  margin-left: 50% }

p.caption {
  font-style: italic }

p.credits {
  font-style: italic ;
  font-size: smaller }

p.label {
  white-space: nowrap }

p.rubric {
  font-weight: bold ;
  font-size: larger ;
  color: maroon ;
  text-align: center }

p.sidebar-title {
  font-family: sans-serif ;
  font-weight: bold ;
  font-size: larger }

p.sidebar-subtitle {
  font-family: sans-serif ;
  font-weight: bold }

p.topic-title {
  font-weight: bold }

pre.address {
  margin-bottom: 0 ;
  margin-top: 0 ;
  font: inherit }

pre.literal-block, pre.doctest-block, pre.math, pre.code {
  margin-left: 2em ;
  margin-right: 2em }

pre.code .ln { color: grey; } /* line numbers */
pre.code, code { background-color: #eeeeee }
pre.code .comment, code .comment { color: #5C6576 }
pre.code .keyword, code .keyword { color: #3B0D06; font-weight: bold }
pre.code .literal.string, code .literal.string { color: #0C5404 }
pre.code .name.builtin, code .name.builtin { color: #352B84 }
pre.code .deleted, code .deleted { background-color: #DEB0A1}
pre.code .inserted, code .inserted { background-color: #A3D289}

span.classifier {
  font-family: sans-serif ;
  font-style: oblique }

span.classifier-delimiter {
  font-family: sans-serif ;
  font-weight: bold }

span.interpreted {
  font-family: sans-serif }

span.option {
  white-space: nowrap }

span.pre {
  white-space: pre }

span.problematic {
  color: red }

span.section-subtitle {
  /* font-size relative to parent (h1..h6 element) */
  font-size: 80% }

table.citation {
  border-left: solid 1px gray;
  margin-left: 1px }

table.docinfo {
  margin: 2em 4em }

table.docutils {
  margin-top: 0.5em ;
  margin-bottom: 0.5em }

table.footnote {
  border-left: solid 1px black;
  margin-left: 1px }

table.docutils td, table.docutils th,
table.docinfo td, table.docinfo th {
  padding-left: 0.5em ;
  padding-right: 0.5em ;
  vertical-align: top }

table.docutils th.field-name, table.docinfo th.docinfo-name {
  font-weight: bold ;
  text-align: left ;
  white-space: nowrap ;
  padding-left: 0 }

/* "booktabs" style (no vertical lines) */
table.docutils.booktabs {
  border: 0px;
  border-top: 2px solid;
  border-bottom: 2px solid;
  border-collapse: collapse;
}
table.docutils.booktabs * {
  border: 0px;
}
table.docutils.booktabs th {
  border-bottom: thin solid;
  text-align: left;
}

h1 tt.docutils, h2 tt.docutils, h3 tt.docutils,
h4 tt.docutils, h5 tt.docutils, h6 tt.docutils {
  font-size: 100% }

ul.auto-toc {
  list-style-type: none }

</style>
</head>
<body>
<div class="document" id="mu0-compiler-and-simulator">
<h1 class="title">Mu0 compiler and simulator</h1>
<table class="docinfo" frame="void" rules="none">
<col class="docinfo-name" />
<col class="docinfo-content" />
<tbody valign="top">
<tr><th class="docinfo-name">Date:</th>
<td>2014-11-13</td></tr>
<tr><th class="docinfo-name">Author:</th>
<td>Nikolaos Kavvadias &lt;<a class="reference external" href="mailto:nikos&#64;nkavvadias.com">nikos&#64;nkavvadias.com</a>&gt;</td></tr>
<tr class="field"><th class="docinfo-name">Email:</th><td class="field-body"><a class="reference external" href="mailto:info&#64;ajaxcompilers.com">info&#64;ajaxcompilers.com</a></td>
</tr>
<tr><th class="docinfo-name">Revision:</th>
<td>0.0.1 (2014-11-13) [copy of the original work by benjya: <a class="reference external" href="http://everything2.com/title/MU0">http://everything2.com/title/MU0</a>]</td></tr>
<tr class="field"><th class="docinfo-name">Web site:</th><td class="field-body"><a class="reference external" href="http://github.com/nkkav/mu0">http://github.com/nkkav/mu0</a></td>
</tr>
</tbody>
</table>
<!-- -*- coding: utf-8 -*- -->
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="auto-toc simple">
<li><a class="reference internal" href="#what-is-the-mu0" id="id2">1&nbsp;&nbsp;&nbsp;What is the MU0?</a></li>
<li><a class="reference internal" href="#the-command-set" id="id3">2&nbsp;&nbsp;&nbsp;The command set</a></li>
<li><a class="reference internal" href="#the-development-environment" id="id4">3&nbsp;&nbsp;&nbsp;The development environment</a></li>
<li><a class="reference internal" href="#compiler-and-debugger-outline-design" id="id5">4&nbsp;&nbsp;&nbsp;Compiler and Debugger outline design</a></li>
<li><a class="reference internal" href="#sample-program-1-multiplication" id="id6">5&nbsp;&nbsp;&nbsp;Sample Program 1 - Multiplication</a></li>
<li><a class="reference internal" href="#sample-program-2-sorting-out-odd-and-even-numbers" id="id7">6&nbsp;&nbsp;&nbsp;Sample Program 2 - Sorting out Odd and Even numbers</a></li>
<li><a class="reference internal" href="#compiler-design" id="id8">7&nbsp;&nbsp;&nbsp;Compiler Design</a><ul class="auto-toc">
<li><a class="reference internal" href="#top-level-design" id="id9">7.1&nbsp;&nbsp;&nbsp;Top Level Design</a></li>
<li><a class="reference internal" href="#compile-pass-1" id="id10">7.2&nbsp;&nbsp;&nbsp;Compile Pass 1</a></li>
<li><a class="reference internal" href="#compile-pass-2" id="id11">7.3&nbsp;&nbsp;&nbsp;Compile Pass 2</a></li>
</ul>
</li>
<li><a class="reference internal" href="#executer-debugger-design" id="id12">8&nbsp;&nbsp;&nbsp;Executer / Debugger design</a><ul class="auto-toc">
<li><a class="reference internal" href="#id1" id="id13">8.1&nbsp;&nbsp;&nbsp;Top Level Design</a></li>
<li><a class="reference internal" href="#execute-commands" id="id14">8.2&nbsp;&nbsp;&nbsp;Execute Commands</a></li>
<li><a class="reference internal" href="#load-code-into-memory" id="id15">8.3&nbsp;&nbsp;&nbsp;Load Code into Memory</a></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="what-is-the-mu0">
<h1><a class="toc-backref" href="#id2">1&nbsp;&nbsp;&nbsp;What is the MU0?</a></h1>
<p>The MU0 is an abstract computer used for educational purposes at the University
of Manchester. I was first exposed to it as part of my under-graduate degree
course at UMIST. It is based on the SSEM computer which was one of the first
computers every built - at the University (and is considered, along with the
Harvard Mark 1 to be the first real computer).</p>
<p>As mentioned, it is used to illustrate basic programming concepts, and
encourages thorough design due to the fact it only has 7 actual commands. This
WU is based on a project I completed at the end of my first year to create a
complete development environment for the &quot;processor&quot;.</p>
</div>
<div class="section" id="the-command-set">
<h1><a class="toc-backref" href="#id3">2&nbsp;&nbsp;&nbsp;The command set</a></h1>
<p>The processor can directly address 4096 words, each 16 bits long. Each word is
capable of storing one fixed length command, which consists of 4 bits of opcode
and 12 bits of operand, in all cases except the STOP command which takes no
operand.</p>
<p>The only internal register is known as the &quot;accumulator&quot; and this is where all
processing must take place. It is 16 bits long, and is where both inputs to
calculations and results must be stored.</p>
<p>The following is a list of all the commands supported in the processor.</p>
<ul class="simple">
<li>Opcode 0: <tt class="docutils literal">ACC&lt;= [address]</tt><ul>
<li>Load accumulator with contents of address</li>
</ul>
</li>
<li>Opcode 1: <tt class="docutils literal">ACC&gt;= [address]</tt><ul>
<li>Store contents of accumulator at address</li>
</ul>
</li>
<li>Opcode 2: <tt class="docutils literal">ACC+ [address]</tt><ul>
<li>Add contents of address to contents of accumulator</li>
</ul>
</li>
<li>Opcode 3: <tt class="docutils literal">ACC- [address]</tt><ul>
<li>Subtract contents of address from contents of accumulator</li>
</ul>
</li>
<li>Opcode 4: <tt class="docutils literal">PC&lt;= address</tt><ul>
<li>Jump to address</li>
</ul>
</li>
<li>Opcode 5: <tt class="docutils literal">IF+VE PC&lt;= address</tt><ul>
<li>If contents of accumulator are positive, jump to address</li>
</ul>
</li>
<li>Opcode 6: <tt class="docutils literal"><span class="pre">IF!=0</span> PC&lt;= address</tt><ul>
<li>If contents of accumulator are not zero, jump to address</li>
</ul>
</li>
<li>Opcode 7: <tt class="docutils literal">STOP</tt><ul>
<li>Stop processor</li>
</ul>
</li>
</ul>
<p>Three major functions, present in most other processors, are missing from the
MU0 instruction set, and these should be noted here.</p>
<ul class="simple">
<li>There is no immediate addressing - such as &quot;Load accumulator with this value&quot;,
only &quot;Load accumulator with contents of address”.</li>
<li>There is no form of jumping to a subroutine with a return value pushed onto a
stack.</li>
<li>There is no form of indexed addressing.</li>
</ul>
<p>Methods to work around all three of these will be illustrated in the program
examples later on in this document.</p>
</div>
<div class="section" id="the-development-environment">
<h1><a class="toc-backref" href="#id4">3&nbsp;&nbsp;&nbsp;The development environment</a></h1>
<p>Although not directly related to the processor itself, the development
environment was a core part of this system and it helps illustrate the way the
processor works. If you want to try compiling these programs (shown at the end),
they were written and compiled on Borland Turbo C 2 (yes, that old!) and also
GCC on HP-UX. You're welcome to use them for anything you want.</p>
<p>The system allows complete development of MU0 programs, from compilation
(assembly really) to execution and debugging. An editor isn't included. The
compiler asks for two filenames - the source MU0 assembly listing, and a
destination for the &quot;executable&quot; code. There is no library and therefore no need
for a linker stage. All the commands listed above are supported, and support is
also provided for putting literals in the code and labels to make jumping around
easier.</p>
<p>The second part of the system is the executer (emulator) / debugger. This is
emulated as a separate program. It reads in the &quot;executable&quot; code and then
executes it in various modes (straight through, trace or single step). The user
can check the contents of memory and the accumulator at any time.</p>
<p>The compiler source code is designed from the bottom up (as the MU0 has never
really existed), but based on other compilers. Comments can be placed anywhere
in a source program, simply by prefixing the line with a semicolon (<tt class="docutils literal">;</tt>). On
seeing this, the compiler should ignore the rest of the line. Blank lines can
also be left anywhere within the program to increase readibility.</p>
<p>Actual commands are written simply as they are listed above, with the operand
either in or out of square brackets <tt class="docutils literal">[]</tt> as the command demands. There should
be a space between the command and the operand, however, and spaces between each
section of the two conditional branch commands. If the first character of the
operand is a dollar sign (<tt class="docutils literal">$</tt>), then the operand is assumed to be a direct
address in hexadecimal. If this isn't present, then the operand is assumed to be
a label.</p>
<p>The position of labels within the text is set by placing <tt class="docutils literal">.label labelname</tt>
within the source code. The next pseudo-op is <tt class="docutils literal">.word hexnumber</tt> which places a
literal 16 bit hexadecimal number in the code. The final pseudo-op is <tt class="docutils literal">.end</tt>
which is used on its own to indicate the end of the source code. Anything placed
after it is completly ignored.</p>
<p>The debugger will have its own command line and simple command line processor,
supporting the following commands.</p>
<dl class="docutils">
<dt><strong>load filename</strong></dt>
<dd>Load MU0 executable code from specified filename into the start of its
<tt class="docutils literal">memory</tt>.</dd>
<dt><strong>go</strong></dt>
<dd>Execute code from the start of &quot;memory&quot; in &quot;trace&quot; mode - displaying each line
on execution but without pausing.</dd>
<dt><strong>goquiet</strong></dt>
<dd>Execute code from the start of &quot;memory&quot; in &quot;quiet&quot; mode - non stop and with no display.</dd>
<dt><strong>gostep</strong></dt>
<dd>Execute code from the start of &quot;memory&quot; in &quot;single step&quot; mode - display each
command on execution and then pause and wait for the user to select to step to
another command, change to &quot;trace&quot; or &quot;quiet&quot; mode, or stop execution.</dd>
<dt><strong>set address value</strong></dt>
<dd>Set specified address in &quot;memory&quot; to specified value.</dd>
<dt><strong>view address</strong></dt>
<dd>View the contents of the specified address in &quot;memory&quot;.</dd>
<dt><strong>viewacc</strong></dt>
<dd>View the contents of the accumulator.</dd>
<dt><strong>setacc value</strong></dt>
<dd>Set the accumulator to the specified value.</dd>
<dt><strong>dump lowadd hiadd</strong></dt>
<dd>Show the contents of all memory locations between the specified addresses.</dd>
<dt><strong>help</strong></dt>
<dd>Display a list of the available commands.</dd>
<dt><strong>exit</strong></dt>
<dd>Quit the debugger.</dd>
</dl>
<p>The design outlines are here, and the complete compiler and debugger source code
has been made available.</p>
</div>
<div class="section" id="compiler-and-debugger-outline-design">
<h1><a class="toc-backref" href="#id5">4&nbsp;&nbsp;&nbsp;Compiler and Debugger outline design</a></h1>
<p>The compiler is of the two pass variety. This is to avoid a major problem with
compilers, that if, during compilation, the compiler encounters a label which is
defined lower down in the source code, it won't know where it is. So, the
compiler makes a first check through the source, not generating any code but
simply building up a list in memory of all the labels and where they point to.
The second pass is then the code generation pass.</p>
<p>For the first pass, only the source file is opened, and the address counter
reset. The program is the stepped through command by command, and for each
command (including the <tt class="docutils literal">.word</tt> pseudo-op) the address counter is incremented.
Therefore, whenever the compiler encounters a <tt class="docutils literal">.label</tt> pseudo-op, it can add
the label together with its address within the code to its internal symbol table
for future reference. Assuming no invalid commands are found during this pass
(including the need for a <tt class="docutils literal">.end</tt> at the end), compilation then moves into the
second pass.</p>
<p>The second pass is the code generation pass. This time, we open both the source
and destination files, and again read in the source file line by line. We also
actually attempt to assemble each command in the source code, and process the
operand, be it an immediate number or a label. If a label is referenced which
isn't already in the symbol table then an error has to be flagged. Again, the
total number of errors is displayed at the end of compilation.</p>
<p>Assuming both stages complete successfully, an output file will remain which can
then be loaded into the debugger and executer.</p>
<p>The debugger must start by defining an &quot;accumulator&quot; and &quot;memory&quot; within
variables to work on. The &quot;accumulator&quot; is 16 bits, and the &quot;memory&quot; must be
large enough to accomodate 4096 words, each 16 bits long.</p>
<p>It is based around a command line, obeying the list of commands given above. All
addresses and values for the display commands, and during stepped or traced
execution, are to be displayed in hexadecimal as this is the standard notation
in computing.</p>
<p>On each step of execution if there is any form of display, the current address,
current executing instruction, and current contents of the accumulator, should
be displayed. If we are in single step mode, this should then be followed by a
prompt to halt execution, change to trace mode, change to quite execution or
continue in single step mode.</p>
<p>It is assumed that the code which is loaded into the debugger will contain only
correct instructions. However, this may not be the case as someone may enter the
wrong filename and load a file which is not MU0 exutable code. Therefore, if
during execution an invalid command is encountered (opcode is greater than
seven) then this should be flagged, but execution continued.</p>
</div>
<div class="section" id="sample-program-1-multiplication">
<h1><a class="toc-backref" href="#id6">5&nbsp;&nbsp;&nbsp;Sample Program 1 - Multiplication</a></h1>
<p>The MU0 has no function to multiply two numbers. This program multiplies the
contents of A0 by A1 storing the result in A2. It also shows the method for
getting round the lack of immediate addressing - a label is created such as
ONE and the actual number number is then placed in this location. The program
to do this is as follows.</p>
<pre class="literal-block">
; Multiply.MU0
; Test Program
; (C) 1994 Benjy
; Reset A2 (where we store the result)
ACC&lt;= [ZR]
ACC=&gt; [$A2]
; Start the main loop
.label LOOP
; Load the result into the accumulator
ACC&lt;= [$A2]
; Add the value
ACC+ [$A0]
; Store it out in the result
ACC=&gt; [$A2]
; Load the multiplier
ACC&lt;= [$A1]
; Subtract 1 from it
ACC- [ONE]
; Store it out
ACC=&gt; [$A1]
; If we haven't got to 0, loop around
IF!=0 PC&lt;= LOOP
; Done
STOP
.label ZR
.word 0
.label ONE
.word 1
.end
</pre>
<p>On compilation, this gives the following.</p>
<pre class="literal-block">
COMPILE_MU0 - companion program to EXECUTE_MU0
(C) 1994 Benjy

Please enter source filename &gt; multiply.mu0
Please enter destination filename &gt; multiply.mu0.exe
Commencing compilation...

Pass 1
Opening source file multiply.mu0
Clearing label index
Label 1 at address [002]: LOOP
Label 2 at address [00A]: ZR
Label 3 at address [00B]: ONE

End of file marker, pass 1 complete

Pass 2
Opening source file multiply.mu0
Opening destination file multiply.mu0.exe

[000] ; Multiply.MU0
[000] ; Test Program
[000] ; (C) 1994 Benjy
[000]
[000] ACC&lt;= [ZR]                    000A
[001] ACC=&gt; [$A2]                   10A2
[002] .label LOOP
[002] ACC&lt;= [$A2]                   00A2
[003] ACC+ [$A0]                    20A0
[004] ACC=&gt; [$A2]                   10A2
[005] ACC&lt;= [$A1]                   00A1
[006] ACC- [ONE]                    300B
[007] ACC=&gt; [$A1]                   10A1
[008] IF!=0 PC&lt;= LOOP               6002
[009] STOP                          7000
[00A]
[00A] .label ZR
[00A] .word 0                       0000
[00B]
[00B] .label ONE
[00B] .word 1                       0001

[00C]
[00C] .end
End of file marker, pass 2 complete
</pre>
<p>The first part of this listing shows the first pass being processed, and the
compiler is only going through the code to identify labels and build up a list
in memory. Pass 2 is the main compilation phase. Each line shows the current
address, a line of source code, and the 16 bit hexadecimal code at the end of
the line. This can be checked through to be correct.</p>
<p>The testing of this program was performed using the debugging program, and
simply consisted of loading the code into &quot;memory&quot;, placing various values in A0
and A1, executing it and checking the value in A2. A sample pass of executing
this program is shown here, multiplying 1A (26) by 06 (6) and giving the correct
answer of 9C (156).</p>
<pre class="literal-block">
EXECUTE_MU0 - companion program to COMPILE_MU0
(C) 1994 Benjy

Enter &quot;help&quot; for command list

&gt; load multiply.mu0.exe
[000] : 000A
[001] : 10A2
[002] : 00A2
[003] : 20A0
[004] : 10A2
[005] : 00A1
[006] : 300B
[007] : 10A1
[008] : 6002
[009] : 7000
[00A] : 0000
[00B] : 0001
&gt; set a0 1a
[0A0] : 001A
&gt; set a1 06
[0A1] : 0006
&gt; go
PC : 000  PI : 000A  ACC : 0000
PC : 001  PI : 10A2  ACC : 0000
PC : 002  PI : 00A2  ACC : 0000
PC : 003  PI : 20A0  ACC : 0000
PC : 004  PI : 10A2  ACC : 001A
PC : 005  PI : 00A1  ACC : 001A
PC : 006  PI : 300B  ACC : 0006
PC : 007  PI : 10A1  ACC : 0005
PC : 008  PI : 6002  ACC : 0005
PC : 002  PI : 00A2  ACC : 0005
PC : 003  PI : 20A0  ACC : 001A
PC : 004  PI : 10A2  ACC : 0034
PC : 005  PI : 00A1  ACC : 0034
PC : 006  PI : 300B  ACC : 0005
PC : 007  PI : 10A1  ACC : 0004
PC : 008  PI : 6002  ACC : 0004
PC : 002  PI : 00A2  ACC : 0004
PC : 003  PI : 20A0  ACC : 0034
PC : 004  PI : 10A2  ACC : 004E
PC : 005  PI : 00A1  ACC : 004E
PC : 006  PI : 300B  ACC : 0004
PC : 007  PI : 10A1  ACC : 0003
PC : 008  PI : 6002  ACC : 0003
PC : 002  PI : 00A2  ACC : 0003
PC : 003  PI : 20A0  ACC : 004E
PC : 004  PI : 10A2  ACC : 0068
PC : 005  PI : 00A1  ACC : 0068
PC : 006  PI : 300B  ACC : 0003
PC : 007  PI : 10A1  ACC : 0002
PC : 008  PI : 6002  ACC : 0002
PC : 002  PI : 00A2  ACC : 0002
PC : 003  PI : 20A0  ACC : 0068
PC : 004  PI : 10A2  ACC : 0082
PC : 005  PI : 00A1  ACC : 0082
PC : 006  PI : 300B  ACC : 0002
PC : 007  PI : 10A1  ACC : 0001
PC : 008  PI : 6002  ACC : 0001
PC : 002  PI : 00A2  ACC : 0001
PC : 003  PI : 20A0  ACC : 0082
PC : 004  PI : 10A2  ACC : 009C
PC : 005  PI : 00A1  ACC : 009C
PC : 006  PI : 300B  ACC : 0001
PC : 007  PI : 10A1  ACC : 0000
PC : 008  PI : 6002  ACC : 0000
PC : 009  PI : 7000  ACC : 0000
&gt; view a2
[0A2] : 009C
&gt; exit
Done
</pre>
</div>
<div class="section" id="sample-program-2-sorting-out-odd-and-even-numbers">
<h1><a class="toc-backref" href="#id7">6&nbsp;&nbsp;&nbsp;Sample Program 2 - Sorting out Odd and Even numbers</a></h1>
<p>The program shown previously is very simple, and for a more extensive test,
another program was written. Its function is to work its way through a list of
numbers starting at memory location 200 going on until 240, and place all even
numbers into a list starting at address 241.</p>
<p>This, on most processors, would make use of &quot;indexed&quot; addressing, whereby the
contents of an index register are added onto the specified address to generate
the true address, making accessing a list very easy. This mode does not exist on
the MU0, so &quot;self modifying&quot; code has to be used instead. This is where the
program actually updates itself during its execution to allow incrementing
through the list. The program also has to check if a number is even or odd, what
would normally be done by shifting the Least Significant Bit into the carry and
branching according to the carry. Again this isn't possible, so instead we
handle the problem by successively subtracting 2 from the number, and seeing if
we get to zero or -1 first, zero indicating an even number.</p>
<p>The code is as follows.</p>
<pre class="literal-block">
; odd_even.mu0
; Finds even numbers in a list
;
; THIS PROGRAM IS SELF-MODIFYING. However, it will ensure
; that it resets itself before each run so it doesn't need
; reloading.
;
; List is from $200 to $240
; Even numbers copied to list starting at $241
;
; Version 1, 13 October 1994
;
; (C) Benjy (Soft Eng A2)

; Start by resetting &quot;indirect&quot; addressing bits
ACC&lt;= [DEF_GET_SOURCE]
ACC=&gt; [GET_SOURCE]
ACC=&gt; [GET_SOURCE_1]
ACC&lt;= [DEF_PUT_DEST]
ACC=&gt; [PUT_DEST]

; Main program loop
.label MAIN_LOOP

; Here is where we get the source number - self modifying
.label GET_SOURCE
ACC&lt;= [$200]

; Now check to see if even by subtracting two many times
.label SUBTRACT_LOOP
; We must check if done first to ensure that 0 works
IF+VE PC&lt;= SUBTRACT_NOT_DONE
PC&lt;= SUBTRACT_DONE
.label SUBTRACT_NOT_DONE
ACC- [TWO]
PC&lt;= SUBTRACT_LOOP

; We now have either -1 (odd) or 0 (even) in ACC.
.label SUBTRACT_DONE
IF!=0 PC&lt;= ODD

; The number is even so copy it to the second list
; This (both commands) are now self modifying
.label GET_SOURCE_1
ACC&lt;= [$200]
.label PUT_DEST
ACC=&gt; [$241]

; Increment the destination index
ACC&lt;= [PUT_DEST]
ACC+ [ONE]
ACC=&gt; [PUT_DEST]

.label ODD
; Now (always) increment the source index
ACC&lt;= [GET_SOURCE]
ACC+ [ONE]
ACC=&gt; [GET_SOURCE]
ACC=&gt; [GET_SOURCE_1]

; And check to see if we've finished
ACC- [END_GET_SOURCE]
IF!=0 PC&lt;= MAIN_LOOP

; All Done
STOP

; Default command to get from source list
.label DEF_GET_SOURCE
ACC&lt;= [$200]

; What the GET_SOURCE will be when we finish
.label END_GET_SOURCE
ACC&lt;= [$241]

; Default command to write to destination list
.label DEF_PUT_DEST
ACC=&gt; [$241]

; Constants
.label ONE
.word 1
.label TWO
.word 2

; End
.end
</pre>
<p>On compiling, the output is as follows.</p>
<pre class="literal-block">
COMPILE_MU0 - companion program to EXECUTE_MU0
(C) 1994 Benjy

Please enter source filename &gt; odd_even.mu0
Please enter destination filename &gt; odd_even.mu0.exe
Commencing compilation...

Pass 1
Opening source file odd_even.mu0
Clearing label index
Label 1 at address [005]: MAIN_LOOP
Label 2 at address [005]: GET_SOURCE
Label 3 at address [006]: SUBTRACT_LOOP
Label 4 at address [008]: SUBTRACT_NOT_DONE
Label 5 at address [00A]: SUBTRACT_DONE
Label 6 at address [00B]: GET_SOURCE_1
Label 7 at address [00C]: PUT_DEST
Label 8 at address [010]: ODD
Label 9 at address [017]: DEF_GET_SOURCE
Label 10 at address [018]: END_GET_SOURCE
Label 11 at address [019]: DEF_PUT_DEST
Label 12 at address [01A]: ONE
Label 13 at address [01B]: TWO

End of file marker, pass 1 complete

Pass 2
Opening source file odd_even.mu0
Opening destination file odd_even.mu0.exe

[000] ; odd_even.mu0
[000] ; Finds even numbers in a list
[000] ;
[000] ; THIS PROGRAM IS SELF-MODIFYING. However, it will ensure
[000] ; that it resets itself before each run so it doesn't need
[000] ; reloading.
[000] ;
[000] ; List is from $200 to $240
[000] ; Even numbers copied to list starting at $241
[000] ;
[000] ; Version 1, 13 October 1994
[000] ;
[000] ; (C) Benjy (Soft Eng A2)
[000]
[000] ; Start by resetting &quot;indirect&quot; addressing bits
[000] ACC&lt;= [DEF_GET_SOURCE]        0017
[001] ACC=&gt; [GET_SOURCE]            1005
[002] ACC=&gt; [GET_SOURCE_1]          100B
[003] ACC&lt;= [DEF_PUT_DEST]          0019
[004] ACC=&gt; [PUT_DEST]              100C
[005]
[005] ; Main program loop
[005] .label MAIN_LOOP
[005]
[005] ; Here is where we get the source number - self modifying
[005] .label GET_SOURCE
[005] ACC&lt;= [$200]                  0200
[006]
[006] ; Now check to see if even by subtracting two many times
[006] .label SUBTRACT_LOOP
[006] ; We must check if done first to ensure that 0 works
[006] IF+VE PC&lt;= SUBTRACT_NOT_DONE  5008
[007] PC&lt;= SUBTRACT_DONE            400A
[008] .label SUBTRACT_NOT_DONE
[008] ACC- [TWO]                    301B
[009] PC&lt;= SUBTRACT_LOOP            4006
[00A]
[00A] ; We now have either -1 (odd) or 0 (even) in ACC.
[00A] .label SUBTRACT_DONE
[00A] IF!=0 PC&lt;= ODD                6010
[00B]
[00B] ; The number is even so copy it to the second list
[00B] ; This (both commands) are now self modifying
[00B] .label GET_SOURCE_1
[00B] ACC&lt;= [$200]                  0200
[00C] .label PUT_DEST
[00C] ACC=&gt; [$241]                  1241
[00D]
[00D] ; Increment the destination index
[00D] ACC&lt;= [PUT_DEST]              000C
[00E] ACC+ [ONE]                    201A
[00F] ACC=&gt; [PUT_DEST]              100C
[010]
[010] .label ODD
[010] ; Now (always) increment the source index
[010] ACC&lt;= [GET_SOURCE]            0005
[011] ACC+ [ONE]                    201A
[012] ACC=&gt; [GET_SOURCE]            1005
[013] ACC=&gt; [GET_SOURCE_1]          100B
[014]
[014] ; And check to see if we've finished
[014] ACC- [END_GET_SOURCE]         3018
[015] IF!=0 PC&lt;= MAIN_LOOP          6005
[016]
[016] ; All Done
[016] STOP                          7000
[017]
[017] ; Default command to get from source list
[017] .label DEF_GET_SOURCE
[017] ACC&lt;= [$200]                  0200
[018]
[018] ; What the GET_SOURCE will be when we finish
[018] .label END_GET_SOURCE
[018] ACC&lt;= [$241]                  0241
[019]
[019] ; Default command to write to destination list
[019] .label DEF_PUT_DEST
[019] ACC=&gt; [$241]                  1241
[01A]
[01A] ; Constants
[01A] .label ONE
[01A] .word 1                       0001
[01B] .label TWO
[01B] .word 2                       0002
[01C]
[01C] ; End
[01C] .end
End of file marker, pass 2 complete
</pre>
<p>A Sample execution is shown now. We load the code, then set some values from
address 200 onwards to various numbers. The code is executed, and the dump shows
the even numbers appear starting at address 241.</p>
<pre class="literal-block">
EXECUTE_MU0 - companion program to COMPILE_MU0
(C) 1994 Benjy

Enter &quot;help&quot; for command list

&gt; load odd_even.mu0.exe
[000] : 0017
[001] : 1005
[002] : 100B
[003] : 0019
[004] : 100C
[005] : 0200
[006] : 5008
[007] : 400A
[008] : 301B
[009] : 4006
[00A] : 6010
[00B] : 0200
[00C] : 1241
[00D] : 000C
[00E] : 201A
[00F] : 100C
[010] : 0005
[011] : 201A
[012] : 1005
[013] : 100B
[014] : 3018
[015] : 6005
[016] : 7000
[017] : 0200
[018] : 0241
[019] : 1241
[01A] : 0001
[01B] : 0002
&gt; set 200 1
[200] : 0001
&gt; set 201 2
[201] : 0002
&gt; set 202 3
[202] : 0003
&gt; set 203 4
[203] : 0004
&gt; set 204 89
[204] : 0089
&gt; set 205 a2
[205] : 00A2
&gt; set 206 b3
[206] : 00B3
&gt; set 207 f1
[207] : 00F1
&gt; set 208 e0
[208] : 00E0
&gt; set 209 12
[209] : 0012
&gt; set 20a 0
[20A] : 0000
&gt; set 20b 15
[20B] : 0015
&gt; set 20c 93
[20C] : 0093
&gt; set 20d d4
[20D] : 00D4
&gt; set 20e f4
[20E] : 00F4
&gt; dump 200 240

[200]  0001 0002 0003 0004  0089 00A2 00B3 00F1
[208]  00E0 0012 0000 0015  0093 00D4 00F4 0000
[210]  0000 0000 0000 0000  0000 0000 0000 0000
[218]  0000 0000 0000 0000  0000 0000 0000 0000
[220]  0000 0000 0000 0000  0000 0000 0000 0000
[228]  0000 0000 0000 0000  0000 0000 0000 0000
[230]  0000 0000 0000 0000  0000 0000 0000 0000
[238]  0000 0000 0000 0000  0000 0000 0000 0000
[240]  0000
&gt; goquiet

&gt; dump 200 240

[200]  0001 0002 0003 0004  0089 00A2 00B3 00F1
[208]  00E0 0012 0000 0015  0093 00D4 00F4 0000
[210]  0000 0000 0000 0000  0000 0000 0000 0000
[218]  0000 0000 0000 0000  0000 0000 0000 0000
[220]  0000 0000 0000 0000  0000 0000 0000 0000
[228]  0000 0000 0000 0000  0000 0000 0000 0000
[230]  0000 0000 0000 0000  0000 0000 0000 0000
[238]  0000 0000 0000 0000  0000 0000 0000 0000
[240]  0000
&gt; dump 241 260

[241]  0002 0004 00A2 00E0  0012 0000 00D4 00F4
[249]  0000 0000 0000 0000  0000 0000 0000 0000
[251]  0000 0000 0000 0000  0000 0000 0000 0000
[259]  0000 0000 0000 0000  0000 0000 0000 0000
&gt; exit
Done
</pre>
</div>
<div class="section" id="compiler-design">
<h1><a class="toc-backref" href="#id8">7&nbsp;&nbsp;&nbsp;Compiler Design</a></h1>
<div class="section" id="top-level-design">
<h2><a class="toc-backref" href="#id9">7.1&nbsp;&nbsp;&nbsp;Top Level Design</a></h2>
<pre class="literal-block">
1  Request Source and Destination Filenames
2  Compile Pass 1
3  If Pass 1 was successful
4    Compile Pass 2
5  End If
</pre>
</div>
<div class="section" id="compile-pass-1">
<h2><a class="toc-backref" href="#id10">7.2&nbsp;&nbsp;&nbsp;Compile Pass 1</a></h2>
<pre class="literal-block">
2.1   Attempt to open Source File
2.2   If Open was not successful
2.3     Display message and return with error
2.4   End If
2.5   Clear Label Symbol Table and Address Counter
2.6   Loop Forever
2.7   Read in Line from File
2.8   If End Of File
2.9     Close File and Return Unexpected EOF
2.10    End If
2.11    If valid command or &quot;.word&quot; operation
2.12      Increment Address Counter
2.13    End If
2.14    If &quot;.label&quot; operation
2.15      Add label into table
2.16    End If
2.17    If &quot;.end&quot;
2.18      Close File, Return successful
2.19    End If
2.20  End Loop
</pre>
</div>
<div class="section" id="compile-pass-2">
<h2><a class="toc-backref" href="#id11">7.3&nbsp;&nbsp;&nbsp;Compile Pass 2</a></h2>
<pre class="literal-block">
4.1   Attempt to open Source File (must be successful)
4.2   Attempt to open Destination File
4.3   If Open was not successful
4.4     Display message and return with error
4.5   End If
4.6   Reset Address Counter
4.7   Loop Forever
4.8     Read in Line from File
4.9     If End Of File
4.10      Close both Files and Return Unexpected EOF
4.11    End If
4.12    If &quot;.word&quot; operation
4.13      Increment Address Counter and output operand
4.14    End If
4.15    If &quot;.label&quot; operation
4.16      Ignore it this time round
4.17    End If
4.18    If &quot;.end&quot; operation
4.19      Close both Files and Return successful
4.20    End If
4.21    If Command (all other cases)
4.22      If Command is valid
4.23        Output command with operand (except for STOP)
4.24      Else
4.25        Output blank entry
4.26      End If
4.27      Increment Address Counter
4.28    End If
4.29  End Loop
</pre>
</div>
</div>
<div class="section" id="executer-debugger-design">
<h1><a class="toc-backref" href="#id12">8&nbsp;&nbsp;&nbsp;Executer / Debugger design</a></h1>
<div class="section" id="id1">
<h2><a class="toc-backref" href="#id13">8.1&nbsp;&nbsp;&nbsp;Top Level Design</a></h2>
<pre class="literal-block">
1  Initialise and Clear 4096 x 16 bit words of &quot;memory&quot; and
-  16 bit accumulator
2  Loop Forever
3   Prompt for Command
4   Case of Command
5     HELP       Show help information
6     EXIT       Exit program
7     VIEW       View one address
8     SET        Set address to value
9     VIEWACC    View accumulator
10    SETACC     Set accumulator to value
11    GO         Execute code in trace mode
12    GOSTEP     Execute code in step mode
13    GOQUIET    Execute code in quiet mode
14    DUMP       Dump chunk of memory to screen
15    LOAD       Load code into memory
16    OTHERWISE  Invalid command
17    End Case
18  End Loop
</pre>
<p>Most of these commands are quite simple and will not be expanded further at this
stage, as they simply involve taking one or two further parameters from the
command string, and either displaying an entry or setting an entry to something
else.</p>
</div>
<div class="section" id="execute-commands">
<h2><a class="toc-backref" href="#id14">8.2&nbsp;&nbsp;&nbsp;Execute Commands</a></h2>
<p>All three execute commands (<tt class="docutils literal">GO</tt>, <tt class="docutils literal">GOSTEP</tt> and <tt class="docutils literal">GOQUIET</tt>) will be dealt
with together, as they will eventually be handled by the same function, which
will have a parameter passed to indicate which mode it's running in. The
numbering will be <tt class="docutils literal">11.?</tt> to correspond to the <tt class="docutils literal">GO</tt> command in the top level
design.</p>
<pre class="literal-block">
11.1  Set Current Address to 0
11.2  Loop Forever
11.3    Fetch contents of memory pointed to by Current Address
11.4    If in Trace or Step mode, display Current Address,
--.-    Command and Accumulator
11.5    Case of Command (4 Most Significant Bits)
11.6      0   Load operand into accumulator
11.7      1   Store accumulator to operand
11.8      2   Add operand to accumulator
11.9      3   Subtract operand from accumulator
11.10     4   Set Current Address to operand
11.11     5   If accumulator is positive, set Current Address
--.--         to operand
11.12     6   If accumulator is not zero, set Current Address
--.--         to operand
11.13     7   Stop program and return to command mode
11.14     OTHERWISE Display error but continue execution (bad command)
11.15   End Case
11.16   Increment Current Address
11.17   If in Step mode
11.18     Prompt and get key for Stop, Change to Trace, Change to
--.--     Quiet or Continue
11.19     Case of key
11.20       Stop  Return to command mode
11.21       Trace Change to Trace mode
11.22       Quiet Change to Quiet mode
11.23       Continue  Continue executing in step mode
11.24     End Case
11.25   End If
11.26 End Loop
</pre>
</div>
<div class="section" id="load-code-into-memory">
<h2><a class="toc-backref" href="#id15">8.3&nbsp;&nbsp;&nbsp;Load Code into Memory</a></h2>
<pre class="literal-block">
15.1  Get Filename from Command Line
15.2  Attempt to Open File
15.3  If Open was not successful
15.4    Return Error to user
15.5  End If
15.6  While Not End Of File
15.7    Get two bytes from file
15.8    Place into &quot;memory&quot;
15.9  End While
15.10 Close File
</pre>
<!-- Local Variables:
mode: indented-text
indent-tabs-mode: nil
sentence-end-double-space: t
fill-column: 80
End: -->
</div>
</div>
</div>
</body>
</html>
